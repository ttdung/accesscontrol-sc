"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const finderAction = async ({ path, name, outputs, depth, maxStringLength, includeDependencies, colorify, prettify, compact, noCompile, }, { config, finder }) => {
    ({
        path,
        name,
        outputs,
        depth,
        maxStringLength,
        includeDependencies,
        colorify,
        prettify,
        compact,
        noCompile,
    } = prepareTaskArguments());
    validateTaskArguments();
    await finder.setFor({
        contractPath: path,
        contractName: name,
        options: {
            noCompile,
        },
    });
    const fullyQualifiedName = finder.getFullyQualifiedName();
    const contractsInfo = [
        {
            path,
            name,
            fullyQualifiedName,
        },
    ];
    if (includeDependencies) {
        const sourceDependenciesInfo = finder.getDependenciesInfo();
        contractsInfo.push(...sourceDependenciesInfo);
    }
    const inspectOptions = {
        colors: colorify,
        depth,
        maxStringLength,
        compact,
    };
    for (const contractInfo of contractsInfo) {
        (0, utils_1.useHeaderConsole)(`@@@@@@@ ${contractInfo.fullyQualifiedName} @@@@@@@`);
        if (contractInfo.fullyQualifiedName !== fullyQualifiedName) {
            await finder.setFor({
                contractPath: contractInfo.path,
                contractName: contractInfo.name,
            });
        }
        for (const output of outputs) {
            const outputName = (0, utils_1.formatOutputName)(output);
            const functionName = `get${outputName.pascalCaseFormat}`;
            // eslint-disable-next-line
            const result = (await finder[functionName]());
            const content = prettify ? result : JSON.stringify(result);
            (0, utils_1.useSubheaderConsole)(`======= ${outputName.humanReadableFormat} ======= (${contractInfo.fullyQualifiedName})`);
            (0, utils_1.useInspectConsole)(content, inspectOptions);
        }
    }
    function prepareTaskArguments() {
        return {
            path: path || config.finder.contract?.path,
            name: name || config.finder.contract?.name,
            outputs: outputs ||
                (config.finder.outputs.length > 0 && config.finder.outputs) ||
                constants_1.SUPPORTED_OUTPUTS,
            depth: depth ?? config.finder.depth,
            maxStringLength: maxStringLength ?? config.finder.maxStringLength,
            includeDependencies: includeDependencies || config.finder.includeDependencies,
            colorify: colorify || config.finder.colorify,
            prettify: prettify || config.finder.prettify,
            compact: compact || config.finder.compact,
            noCompile: noCompile || config.finder.noCompile,
        };
    }
    function validateTaskArguments() {
        // eslint-disable-next-line
        outputs.forEach((output) => {
            if (!constants_1.SUPPORTED_OUTPUTS.includes(output)) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, (0, utils_1.useErrorMessage)(`Unsupported Output: '${output}'.\n` +
                    `All supported contract outputs: ${constants_1.SUPPORTED_OUTPUTS.toString()}`));
            }
        });
    }
};
(0, config_1.task)(constants_1.TASK_FINDER)
    .addOptionalParam("path", "Path to the contract file.", undefined, config_1.types.inputFile)
    .addOptionalParam("name", "Name of the contract.", undefined, config_1.types.string)
    .addOptionalVariadicPositionalParam("outputs", `Types of output the contract wants to print. All supported outputs: ${constants_1.SUPPORTED_OUTPUTS.toString()}`, undefined, config_1.types.string)
    .addOptionalParam("depth", "The maximum number of nested JSON objects to be printed in outputs.", undefined, config_1.types.int)
    .addOptionalParam("maxStringLength", "The maximum number of string lengths to be printed in outputs.", undefined, config_1.types.int)
    .addFlag("includeDependencies", "Include contract dependencies in outputs.")
    .addFlag("colorify", "Colorize the outputs.")
    .addFlag("prettify", "Beautify the outputs.")
    .addFlag("compact", "Compact the outputs.")
    .addFlag("noCompile", "Don't compile before running this task.")
    .setDescription("Find various outputs of any existing contracts.")
    .setAction(finderAction);
//# sourceMappingURL=finder.js.map