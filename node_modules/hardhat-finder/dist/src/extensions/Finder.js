"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Finder = void 0;
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const plugins_1 = require("hardhat/plugins");
const path_1 = require("path");
const config_1 = require("../config");
const constants_1 = require("../constants");
const utils_1 = require("../utils");
// TODO: add setByAddress (hardhat --network foo finder ...)
// TODO: add asm, function-debug, function-debug-runtime, flatten source
class Finder {
    constructor(hre) {
        this.compiledOnce = false;
        this.warnedOnce = false;
        this.setFor = async ({ contractPath, contractName, compilerTaskArgs, options, } = {}) => {
            contractPath ?? (contractPath = this.hre.userConfig?.finder?.contract?.path);
            contractName ?? (contractName = this.hre.userConfig?.finder?.contract?.name);
            if (!contractPath || !contractName) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, (0, utils_1.useErrorMessage)("Contract path or name not found!\n" +
                    "Make sure the Finder.setFor() arguments are correctly provided, or 'finder.contract' is set in your Hardhat config."));
            }
            const { noCompile, hideWarnings } = (0, utils_1.merge)(config_1.defaultExtensionOptions, options);
            compilerTaskArgs = (0, utils_1.merge)(config_1.defaultExtensionCompilerTaskArgs, compilerTaskArgs, { noFinder: config_1.defaultExtensionCompilerTaskArgs.noFinder });
            if (!noCompile && !this.compiledOnce) {
                this.compiledOnce = true;
                await this.compile(compilerTaskArgs);
            }
            else {
                if (!this.compiledOnce && !this.warnedOnce) {
                    this.warnedOnce = true;
                    if (!hideWarnings) {
                        (0, utils_1.useWarningConsole)("These arguments or functions do NOT work as expected when 'noCompile' option is true:\n" +
                            "- storage-layout / getStorageLayout()");
                    }
                }
            }
            this.setInitialContractInfo(contractPath, contractName);
            this.contractArtifact = this.getArtifact();
            this.contractBuildInfo = await this.getBuildInfo();
            this.contractOutput =
                this.contractBuildInfo.output.contracts[this.contractPath][this.contractName];
            this.contractMetadata = this.getMetadata();
        };
        this.getArtifact = () => {
            try {
                const artifact = this.hre.artifacts.readArtifactSync(this.contractFullyQualifiedName);
                return artifact;
            }
            catch (error) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, (0, utils_1.useErrorMessage)("There is no Artifact for target contract.\n" +
                    "Make sure the contract path and name are valid.\n" +
                    "Make sure the artifacts exist.\n" +
                    "Compile with hardhat or re-run this task without --no-compile flag to create new artifacts."), error);
            }
        };
        this.getBuildInfo = async () => {
            const buildInfo = await this.hre.artifacts.getBuildInfo(this.contractFullyQualifiedName);
            if (!buildInfo) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, (0, utils_1.useErrorMessage)("There is no Build Info for target contract.\n" +
                    "Make sure the contract path and name are valid.\n" +
                    "Make sure the artifacts exist.\n" +
                    "Compile with hardhat or re-run this task without --no-compile flag to create new artifacts."));
            }
            return buildInfo;
        };
        this.getAbi = () => {
            const abi = this.contractArtifact.abi;
            return abi;
        };
        this.getMetadata = () => {
            const metadataStr = this.contractOutput.metadata;
            let metadata;
            try {
                metadata = JSON.parse(metadataStr);
            }
            catch (error) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, (0, utils_1.useErrorMessage)("Invalid metadata file."), error);
            }
            return metadata;
        };
        this.getBytecode = () => {
            const bytecode = this.contractArtifact.bytecode;
            return bytecode;
        };
        this.getBytecodeRuntime = () => {
            const bytecodeRuntime = this.contractArtifact.deployedBytecode;
            return bytecodeRuntime;
        };
        this.getLinkReferences = () => {
            const linkReferences = this.contractArtifact.linkReferences;
            return linkReferences;
        };
        this.getLinkReferencesRuntime = () => {
            const linkReferencesRuntime = this.contractArtifact.deployedLinkReferences;
            return linkReferencesRuntime;
        };
        this.getImmutableReferences = () => {
            const immutableReferences = this.contractOutput.evm.bytecode.immutableReferences;
            return immutableReferences;
        };
        this.getImmutableReferencesRuntime = () => {
            const immutableReferencesRuntime = this.contractOutput.evm.deployedBytecode.immutableReferences;
            return immutableReferencesRuntime;
        };
        this.getSourceCode = () => {
            const allSources = this.contractBuildInfo.input.sources;
            return allSources[this.contractPath].content;
        };
        this.getDependenciesSourceCode = () => {
            const allSources = this.contractBuildInfo.input.sources;
            const sourceDependenciesInfo = this.getDependenciesInfo();
            const sourceDependencies = new Object();
            for (const sourceDependencyInfo of sourceDependenciesInfo)
                sourceDependencies[sourceDependencyInfo.path] =
                    allSources[sourceDependencyInfo.path].content;
            return sourceDependencies;
        };
        this.getDependenciesInfo = () => {
            const paths = Object.keys(this.contractMetadata.sources).filter((source) => source !== this.contractPath);
            const sourceDependenciesInfo = [];
            for (const path of paths) {
                const name = Object.keys(this.contractBuildInfo.output.contracts[path])[0];
                const sourceDependencyInfo = {
                    path,
                    name,
                    fullyQualifiedName: `${path}:${name}`,
                };
                sourceDependenciesInfo.push(sourceDependencyInfo);
            }
            return sourceDependenciesInfo;
        };
        this.getSettings = () => {
            const settings = this.contractBuildInfo.input.settings;
            return settings;
        };
        this.getSolcVersion = () => {
            const solcVersion = {
                short: this.contractBuildInfo.solcVersion,
                long: this.contractBuildInfo.solcLongVersion,
            };
            return solcVersion;
        };
        this.getAst = () => {
            const ast = this.contractBuildInfo.output.sources[this.contractPath].ast;
            return ast;
        };
        this.getMethodIdentifiers = () => {
            const methodIdentifiers = this.contractOutput.evm.methodIdentifiers;
            return methodIdentifiers;
        };
        this.getOpcodes = () => {
            const opcodes = this.contractOutput.evm.bytecode.opcodes;
            return opcodes;
        };
        this.getOpcodesRuntime = () => {
            const opcodesRuntime = this.contractOutput.evm.deployedBytecode.opcodes;
            return opcodesRuntime;
        };
        this.getStorageLayout = () => {
            return this.contractOutput.storageLayout;
        };
        this.getFullyQualifiedName = () => {
            const contractFullyQualifiedName = `${this.contractPath}:${this.contractName}`;
            return contractFullyQualifiedName;
        };
        this.getDeveloperDocument = () => {
            const devdoc = this.contractMetadata.output.devdoc;
            return devdoc;
        };
        this.getUserDocument = () => {
            const userdoc = this.contractMetadata.output.userdoc;
            return userdoc;
        };
        this.getGeneratedSources = () => {
            const generatedSources = this.contractOutput.evm.bytecode.generatedSources;
            return generatedSources;
        };
        this.getGeneratedSourcesRuntime = () => {
            const generatedSourcesRuntime = this.contractOutput.evm.deployedBytecode.generatedSources;
            return generatedSourcesRuntime;
        };
        this.getSourceMap = () => {
            const sourceMap = this.contractOutput.evm.bytecode.sourceMap;
            return sourceMap;
        };
        this.getSourceMapRuntime = () => {
            const sourceMapRuntime = this.contractOutput.evm.deployedBytecode.sourceMap;
            return sourceMapRuntime;
        };
        this.setInitialContractInfo = (contractPath, contractName) => {
            const userRootPath = this.hre.userConfig?.paths?.root
                ? `${(0, path_1.normalize)(this.hre.userConfig.paths.root)}/`
                : "";
            this.validate((this.contractPath = (0, path_1.normalize)(contractPath).replace(userRootPath, "")), (this.contractName = contractName));
            this.contractFullyQualifiedName = this.getFullyQualifiedName();
        };
        this.validate = (contractPath, contractName) => {
            const contractPathRegexp = new RegExp("\\.sol$");
            if (!contractPathRegexp.test(contractPath)) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, (0, utils_1.useErrorMessage)(`Invalid Path File: '${contractPath}'.\n` +
                    "Make sure the contract path points to a '.sol' file.\n" +
                    "Example: contracts/Foo.sol"));
            }
            const contractNameRegexp = new RegExp("^[\\w\\d$]+$", "i");
            if (!contractNameRegexp.test(contractName)) {
                throw new plugins_1.HardhatPluginError(constants_1.PLUGIN_NAME, (0, utils_1.useErrorMessage)(`Invalid contract name: '${contractName}'.`));
            }
        };
        this.compile = async (taskArgs) => {
            for (const compiler of this.hre.config.solidity.compilers) {
                // TODO: check for more outputs https://docs.soliditylang.org/en/v0.8.17/using-the-compiler.html
                // To select all outputs the compiler can possibly generate, use
                // "outputSelection: { "*": { "*": [ "*" ], "": [ "*" ] } }"
                compiler.settings.outputSelection["*"]["*"].push("storageLayout");
            }
            await this.hre.run(task_names_1.TASK_COMPILE, taskArgs);
        };
        this.hre = hre;
    }
}
exports.Finder = Finder;
//# sourceMappingURL=Finder.js.map